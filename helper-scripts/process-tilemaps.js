import fs from 'fs';
import {argv, argv0, exit} from 'node:process'

// note re: argv
// if we execute "node myscript.js path/to/thing" 
// - arg[0] is the full node path (e.g. "/usr/bin/node")
// - arg[1] is the full script path (e.g. "/usr/Documents/project/myscript.js")
// - arg[2] finally reaches the first argument we gave the script ("path/to/thing")

const sourceDir = argv[2];
const targetDir = argv[3];

if (sourceDir == null || targetDir == null) {
  console.log(`INCOMPLETE COMMAND\nusage: ${argv0} path/to/read-maps/ path/to/write-maps/`);
  exit(1);
}

const LOG_TILESET_FIXES = false;

let warnings = [];
let fileCount = 0; // count the files we process for reporting in output
let fileNames = [];
let importInfo = {};
let pickupLocations = [];


fileNames = fs.readdirSync(sourceDir);
fileNames.forEach((fileName) => {
  // skip files that aren't maps
  if (!(fileName.endsWith('.tmj') || fileName.endsWith('.json'))) {
    return;
  }
  processTileMapFile(fileName);
  fileCount++;
})

writeImportFile("src/worldMapConfig.js");

logOutput();



// Functions

function processTileMapFile(fileName) {
  let content = fs.readFileSync(sourceDir + fileName, {encoding: 'utf-8'});
  let data = JSON.parse(content);

  let nameMatch = fileName.match(/world_x(\d\d)_y(\d\d)/);

  if (nameMatch == null) {
    let msg = `WARNING: file name "${fileName}" does not match expected naming scheme and will be skipped!`;
    warnings.push(msg);
    return false;
  }

  let worldX = parseInt(nameMatch[1]);
  let worldY = parseInt(nameMatch[2]);

  fixTileMapFile(fileName, data);
  addImportInfo(fileName, worldX, worldY);
  gatherExtraConfigData(data, worldX, worldY);
}


function addImportInfo(fileName, worldX, worldY) {
  if (!isNaN(worldX) && !isNaN(worldY)) {
    let tilemapKey = `world-${worldX},${worldY}`;
    importInfo[tilemapKey] = fileName;
    return true;
  } else {
    let msg = `WARNING: file name "${fileName}" does not match expected naming scheme and will be omitted from the import file!`;
    warnings.push(msg);
    return false;
  }
}


function writeImportFile(filePath) {
  let content = "/* THIS FILE IS GENERATED BY A HELPER SCRIPT.*/\n";
  content += "/* DO NOT EDIT THIS FILE DIRECTLY, AS YOUR EDITS MAY BE OVERWRITTEN. */\n\n";
  content += "export const worldMapImports = " + JSON.stringify(importInfo, null, 2) + ";\n";
  content += "export const pickupLocations = " + JSON.stringify(pickupLocations, null, 2) + ";\n";
  fs.writeFileSync(filePath, content);
  console.log("wrote import file to " + filePath);
}


function gatherExtraConfigData(data, worldX, worldY) {
  data.layers.forEach((layer) => {
    if (layer["type"] !== "objectgroup") {
      // right now we only care about tile layers
      return;
    }

    layer.objects.forEach((objectData, index) => {
      if (objectData.name.toLowerCase() === "pickup") {
        objectData.name = "Pickup"; // standardize case while we're here
        pickupLocations.push({
          id : getCustomProperty(objectData, "id"),
          worldX : worldX,
          worldY : worldY,
          levelX : parseInt(objectData.x),
          levelY : parseInt(objectData.y),
        });
        console.log(pickupLocations);
      }
    });
  });
}

function fixTileMapFile(fileName, data) {
  let fixedFile = false;
  let minTileId = 0;
  let maxTileId = 0;

  // filter out non-embedded tilesets whilst ascertaining the viable tile id range
  data.tilesets = data.tilesets.filter((tileset)=>{
    if (tileset.name && tileset.image && tileset.src === undefined) { // make sure this is an embedded tileset
      // get the id range
      if (minTileId > 0 || maxTileId > 0) {
        console.warn(`warning: multiple embedded tilesets found in ${fileName}. only one is supported. beware!`);
      } else {
        minTileId = tileset.firstgid;
        maxTileId = tileset.tilecount - minTileId;
      }
      return true;
    } else {
      if (LOG_TILESET_FIXES) {
        warnings.push(`non-embedded tileset found in file "${fileName}"`);
      }
      // this is NOT an embedded tileset.
      // let's remove it, to get rid of warnings from phaser (and to make the file a slightly smaller download)
      return false;
    }
  });

  if (data.tilesets.length === 0) {
    // if there's nothing left after filtering, there are no embedded tilesets
    warnings.push(`no embedded tilesets found in file "${fileName}" -- UNABLE TO PROCESS`);
    return;
  }

  data.layers.forEach((layer) => {
    if (layer["type"] !== "tilelayer") {
      // skip non-tile layers
      return;
    }

    let warnedLayer = false;

    layer.data.forEach((tileId, index) => {
      // skip "empty" tiles
      if (tileId == 0) {
        return;
      }

      let foundFix = false;
      
      if (tileId < minTileId) {
        tileId += minTileId;
        foundFix = true;
      } else if (tileId > maxTileId) {
        tileId -= (maxTileId + 1);
        foundFix = true;
      }

      if (foundFix) {
        if (LOG_TILESET_FIXES && !warnedLayer) {
          warnings.push(`out of range tile found in file "${fileName}", layer "${layer.name}"`);
          warnedLayer = true;
        }
        layer.data[index] = tileId;
      }
      fixedFile = fixedFile || foundFix;
    });
  });

  // check for audioloops
  const audioloopsDeclaration = getCustomProperty(data, "audioloops");
  if (!audioloopsDeclaration) {
    warnings.push(`${fileName} has no ambient audio defined`);
  }

  // even if we haven't fixed anything, we should re-write the file
  // -- we'll be stripping whitespace this way, and making it a smaller download
  fs.writeFileSync(targetDir + fileName, JSON.stringify(data));
}

function getCustomProperty(data, propName) { 
  // note: the "custom property" format is the same for map data, tile data, object data, etc.
  const soughtProp = data.properties ? data.properties.find((prop) => prop.name === propName) : null;

  if (soughtProp) {
    return soughtProp.value;
  } else {
    return null;
  }
}


function logOutput() {
  console.log(`found ${warnings.length} issues to report in ${fileCount} files`);
  warnings.forEach((warning)=>{
    console.warn('â€¢ ' + warning);
  });
}
