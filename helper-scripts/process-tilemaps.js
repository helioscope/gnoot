import fs from 'fs';
import {argv, argv0, exit} from 'node:process'

// note re: argv
// if we execute "node myscript.js path/to/thing" 
// - arg[0] is the full node path (e.g. "/usr/bin/node")
// - arg[1] is the full script path (e.g. "/usr/Documents/project/myscript.js")
// - arg[2] finally reaches the first argument we gave the script ("path/to/thing")

const sourceDir = argv[2];
const targetDir = argv[3];

if (sourceDir == null || targetDir == null) {
  console.log(`INCOMPLETE COMMAND\nusage: ${argv0} path/to/read-maps/ path/to/write-maps/`);
  exit(1);
}

let warnings = [];
let fileCount = 0; // count the files we process for reporting in output
let fileNames = [];
let importInfo = {};


fileNames = fs.readdirSync(sourceDir);
fileNames.forEach((fileName) => {
  
  // skip files that aren't maps
  if (!(fileName.endsWith('.tmj') || fileName.endsWith('.json'))) {
    return;
  }

  addImportInfo(fileName);

  fixTileMapFile(fileName);
  
  fileCount++;
})

logOutput();
writeImportFile("src/worldMapConfig.js");



// Functions

function addImportInfo(fileName) {
  let nameMatch = fileName.match(/world_x(\d\d)_y(\d\d)/);

  if (nameMatch == null) {
    let msg = `WARNING: file name "${fileName}" does not match expected naming scheme and will be omitted from the import file!`;
    warnings.push(msg);
    return false;
  }

  let worldX = parseInt(nameMatch[1]);
  let worldY = parseInt(nameMatch[2]);

  if (!isNaN(worldX) && !isNaN(worldY)) {
    let tilemapKey = `world-${worldX},${worldY}`;
    importInfo[tilemapKey] = fileName;
    return true;
  } else {
    let msg = `WARNING: file name "${fileName}" does not match expected naming scheme and will be omitted from the import file!`;
    warnings.push(msg);
    return false;
  }
}


function writeImportFile(filePath) {
  let content = "/* THIS FILE IS GENERATED BY A HELPER SCRIPT.*/\n";
  content += "/* DO NOT EDIT THIS FILE DIRECTLY, AS YOUR EDITS MAY BE OVERWRITTEN. */\n\n";
  content += "export const worldMapImports = " + JSON.stringify(importInfo, null, 2) + ";\n";
  fs.writeFileSync(filePath, content);
  console.log("wrote import file to " + filePath);
}


function fixTileMapFile(fileName) {
  let content = fs.readFileSync(sourceDir + fileName, {encoding: 'utf-8'});
  let fixedFile = false;
  let data = JSON.parse(content);
  let minTileId = 0;
  let maxTileId = 0;

  // filter out non-embedded tilesets whilst ascertaining the viable tile id range
  data.tilesets = data.tilesets.filter((tileset)=>{
    if (tileset.name && tileset.image && tileset.src === undefined) { // make sure this is an embedded tileset
      // get the id range
      if (minTileId > 0 || maxTileId > 0) {
        console.warn(`warning: multiple embedded tilesets found in ${fileName}. only one is supported. beware!`);
      } else {
        minTileId = tileset.firstgid;
        maxTileId = tileset.tilecount - minTileId;
      }
      return true;
    } else {
      warnings.push(`non-embedded tileset found in file "${fileName}"`);
      // this is NOT an embedded tileset.
      // let's remove it, to get rid of warnings from phaser (and to make the file a slightly smaller download)
      return false;
    }
  });

  if (data.tilesets.length === 0) {
    warnings.push(`no embedded tilesets found in file "${fileName}" -- UNABLE TO PROCESS`);
    return;
  }

  data.layers.forEach((layer) => {
    if (layer["type"] !== "tilelayer") {
      // skip non-tile layers
      return;
    }

    let warnedLayer = false;

    layer.data.forEach((tileId, index) => {
      // skip "empty" tiles
      if (tileId == 0) {
        return;
      }

      let foundFix = false;
      
      if (tileId < minTileId) {
        tileId += minTileId;
        foundFix = true;
      } else if (tileId > maxTileId) {
        tileId -= (maxTileId + 1);
        foundFix = true;
      }

      if (foundFix) {
        if (!warnedLayer) {
          warnings.push(`out of range tile found in file "${fileName}", layer "${layer.name}"`);
          warnedLayer = true;
        }
        layer.data[index] = tileId;
      }
      fixedFile = fixedFile || foundFix;
    });
  });

  // even if we haven't fixed anything, we should re-write the file
  // -- we'll be stripping whitespace this way, and making it a smaller download
  fs.writeFileSync(targetDir + fileName, JSON.stringify(data));
}


function logOutput() {
  console.log(`found ${warnings.length} issues in ${fileCount} files`);
  warnings.forEach((warning)=>{
    console.warn('â€¢ ' + warning);
  });
}
